<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PEARS - DEV - Swap on Base</title>
    <link rel="preconnect" href="https://api.0x.org">
    <link rel="dns-prefetch" href="//api.0x.org">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Background Effects */
        .bg-effect {
            position: absolute;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(254, 116, 91, 0.08) 0%, transparent 70%);
            border-radius: 50%;
            top: 10%;
            right: 5%;
            animation: float 8s ease-in-out infinite;
        }

        .bg-effect-2 {
            position: absolute;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(254, 116, 91, 0.05) 0%, transparent 70%);
            border-radius: 50%;
            bottom: 20%;
            left: 10%;
            animation: float 12s ease-in-out infinite reverse;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px 40px;
            position: relative;
            z-index: 10;
        }

        .logo {
            height: 120px;
            width: auto;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 24px;
            margin-top: 20px;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-weight: 500;
            font-size: 16px;
            transition: all 0.3s ease;
            padding: 8px 16px;
            border-radius: 8px;
        }

        .nav-link:hover, .nav-link.active {
            color: #FE745B;
            background: rgba(254, 116, 91, 0.1);
        }

        .connect-wallet {
            background: linear-gradient(45deg, #FE745B, #FF8A6B);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connect-wallet.not-connected {
            animation: subtleGlow 3s ease-in-out infinite;
        }

        @keyframes subtleGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(254, 116, 91, 0.3);
            }
            50% {
                box-shadow: 0 0 20px rgba(254, 116, 91, 0.5);
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .connect-wallet:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(254, 116, 91, 0.4);
        }

        /* DEV Banner */
        .dev-banner {
            background: linear-gradient(90deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            text-align: center;
            padding: 8px;
            font-weight: 600;
            font-size: 14px;
            position: relative;
            z-index: 100;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px 20px;
            position: relative;
        }

        /* Swap Container */
        .swap-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(254, 116, 91, 0.2);
            border-radius: 24px;
            padding: 32px;
            width: 100%;
            max-width: 480px;
            position: relative;
        }

        .swap-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .swap-title {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(45deg, #FE745B, #FF8A6B);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        .swap-subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
        }

        /* Token Input */
        .token-input {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            position: relative;
        }

        .token-input-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .token-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            font-weight: 500;
        }

        .token-balance {
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .token-balance:hover {
            color: #FE745B;
            transform: scale(1.05);
        }

        .token-balance.clickable {
            color: rgba(254, 116, 91, 0.8);
        }

        .token-balance.clickable:hover {
            color: #FE745B;
            text-shadow: 0 0 8px rgba(254, 116, 91, 0.5);
        }

        .token-input-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            padding-right: 0px;
        }

        .amount-input {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            font-weight: 600;
            flex: 1;
            outline: none;
            min-width: 0;
        }

        .amount-input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .token-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            color: white;
            font-weight: 500;
            flex-shrink: 0;
        }

        .token-selector:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .token-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #FE745B;
            object-fit: cover;
        }

        /* Switch Button */
        .switch-container {
            display: flex;
            justify-content: center;
            margin: 8px 0;
            position: relative;
        }

        .switch-button {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(254, 116, 91, 0.3);
            border-radius: 12px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            font-size: 18px;
        }

        .switch-button:hover {
            border-color: #FE745B;
            background: rgba(254, 116, 91, 0.1);
            transform: rotate(180deg);
        }

        /* Swap Button */
        .swap-button {
            width: 100%;
            background: linear-gradient(45deg, #FE745B, #FF8A6B);
            color: white;
            border: none;
            padding: 18px;
            border-radius: 16px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 24px;
        }

        .swap-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(254, 116, 91, 0.4);
        }

        .swap-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Status Message */
        .status-message {
            margin-top: 16px;
            padding: 12px 16px;
            border-radius: 12px;
            text-align: center;
            font-size: 14px;
            display: none;
            position: relative;
        }

        .status-message.success {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }

        .status-message.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .status-message.info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }

        .status-message a {
            color: #FE745B;
            text-decoration: none;
            font-weight: 500;
        }

        .status-message a:hover {
            text-decoration: underline;
        }

        .close-status {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: currentColor;
            opacity: 0.6;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 0;
            width: 20px;
            height: 20px;
        }

        .close-status:hover {
            opacity: 1;
        }

        /* Main Content Spacing */
        .main-content {
            margin-bottom: 80px;
        }

        /* Footer */
        .footer {
            background: rgba(255, 255, 255, 0.02);
            border-top: 1px solid rgba(254, 116, 91, 0.1);
            padding: 60px 40px 40px;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 60px;
            align-items: start;
        }

        .footer-socials h3 {
            color: #FE745B;
            font-size: 18px;
            margin-bottom: 24px;
            font-weight: 600;
        }

        .social-icons {
            display: flex;
            gap: 16px;
        }

        .social-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
            padding: 0 12px;
            background: rgba(254, 116, 91, 0.1);
            border: 1px solid rgba(254, 116, 91, 0.2);
            border-radius: 8px;
            color: #FE745B;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .social-icon:hover {
            background: rgba(254, 116, 91, 0.2);
            transform: translateY(-2px);
        }

        .footer-links h3 {
            color: #FE745B;
            font-size: 18px;
            margin-bottom: 24px;
            font-weight: 600;
        }

        .footer-links-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .footer-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            font-size: 16px;
            transition: color 0.3s ease;
            cursor: pointer;
        }

        .footer-link:hover {
            color: #FE745B;
        }

        /* Coming Soon Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(254, 116, 91, 0.2);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .modal h3 {
            color: #FE745B;
            font-size: 24px;
            margin-bottom: 16px;
        }

        .modal p {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 24px;
        }

        .modal-close {
            background: linear-gradient(45deg, #FE745B, #FF8A6B);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .modal-close:hover {
            transform: translateY(-2px);
        }

        /* Token Modal */
        .token-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .token-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(254, 116, 91, 0.2);
            border-radius: 20px;
            padding: 24px;
            width: 90%;
            max-width: 400px;
            max-height: 500px;
        }

        .token-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .token-modal-title {
            font-size: 20px;
            font-weight: 600;
            color: white;
        }

        .close-modal {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .token-search {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px 16px;
            color: white;
            font-size: 16px;
            outline: none;
            margin-bottom: 16px;
        }

        .token-search::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .token-list {
            max-height: 300px;
            overflow-y: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .token-list::-webkit-scrollbar {
            display: none;
        }

        .token-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .token-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .token-item-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #FE745B;
            object-fit: cover;
        }

        .token-item-info {
            flex: 1;
        }

        .token-item-symbol {
            font-weight: 600;
            color: white;
            font-size: 16px;
        }

        .token-item-name {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }

        /* Mobile Logo */
        .mobile-logo-container {
            display: none;
            text-align: center;
            padding: 24px 0 0 0;
            margin-bottom: -60px;
            position: relative;
        }

        .mobile-logo {
            height: 200px;
            position: relative;
            left: -30px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 16px 20px;
                justify-content: center;
                align-items: center;
            }

            .logo {
                display: none;
            }

            .header-right {
                gap: 16px;
                margin-top: 0;
                justify-content: center;
                flex-wrap: wrap;
            }

            .mobile-logo-container {
                display: block;
            }

            .nav-link {
                font-size: 14px;
                padding: 6px 12px;
            }

            .connect-wallet {
                padding: 10px 20px;
                font-size: 14px;
            }

            .main-content {
                padding: 20px 16px;
            }

            .swap-container {
                padding: 24px;
            }

            .swap-title {
                font-size: 24px;
            }

            .amount-input {
                font-size: 20px;
            }

            .token-modal-content {
                width: 95%;
                padding: 20px;
            }

            .footer-content {
                grid-template-columns: 1fr;
                gap: 40px;
                text-align: center;
            }

            .footer {
                padding: 40px 20px 30px;
            }

            .social-icons {
                justify-content: center;
                gap: 8px;
                flex-wrap: wrap;
            }

            .social-icon {
                font-size: 12px;
                min-width: 35px;
                height: 35px;
                padding: 0 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- DEV Banner -->
        <div class="dev-banner">
            🚧 DEVELOPMENT VERSION - Enhanced Token Selector 🚧
        </div>

        <!-- Background Effects -->
        <div class="bg-effect"></div>
        <div class="bg-effect-2"></div>

        <!-- Header -->
        <div class="header">
            <a href="/dev"><img src="Logo Pears.png" alt="PEARS" class="logo"></a>
            <div class="header-right">
                <a href="/" class="nav-link">Live</a>
                <a href="/dev" class="nav-link active">Dev</a>
                <a href="/roadmap" class="nav-link">Roadmap</a>
                <button class="connect-wallet not-connected" id="connectWallet">Connect Base Wallet</button>
            </div>
        </div>

        <!-- Mobile Logo -->
        <div class="mobile-logo-container">
            <a href="/dev"><img src="Logo Pears.png" alt="PEARS" class="mobile-logo"></a>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="swap-container">
                <div class="swap-header">
                    <h1 class="swap-title">Swap on Base</h1>
                    <p class="swap-subtitle">Lightning fast • 0.08% fees • MEV protected </p>
                </div>

                <!-- From Token -->
                <div class="token-input">
                    <div class="token-input-header">
                        <span class="token-label">From</span>
                        <span class="token-balance clickable" id="fromBalance">Balance: 0</span>
                    </div>
                    <div class="token-input-main">
                        <input type="text" class="amount-input" id="fromAmount" placeholder="0">
                        <button class="token-selector" id="fromTokenSelector">
                            <img class="token-icon" id="fromTokenIcon" src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png" alt="ETH">
                            <span id="fromTokenSymbol">ETH</span>
                            <span>▼</span>
                        </button>
                    </div>
                </div>

                <!-- Switch Button -->
                <div class="switch-container">
                    <button class="switch-button" id="switchTokens">⇅</button>
                </div>

                <!-- To Token -->
                <div class="token-input">
                    <div class="token-input-header">
                        <span class="token-label">To</span>
                        <span class="token-balance" id="toBalance">Balance: 0</span>
                    </div>
                    <div class="token-input-main">
                        <input type="text" class="amount-input" id="toAmount" placeholder="0" readonly>
                        <button class="token-selector" id="toTokenSelector">
                            <img class="token-icon" id="toTokenIcon" src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png" alt="USDC">
                            <span id="toTokenSymbol">USDC</span>
                            <span>▼</span>
                        </button>
                    </div>
                </div>

                <!-- Swap Button -->
                <button class="swap-button" id="swapButton" disabled>Connect Wallet</button>

                <!-- Status Message -->
                <div class="status-message" id="statusMessage"></div>
            </div>
        </div>

        <!-- Token Selection Modal -->
        <div class="token-modal" id="tokenModal">
            <div class="token-modal-content">
                <div class="token-modal-header">
                    <span class="token-modal-title">Select Token</span>
                    <button class="close-modal" id="closeModal">×</button>
                </div>
                <input type="text" class="token-search" id="tokenSearch" placeholder="Search tokens or paste address">
                <div class="token-list" id="tokenList"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let provider = null;
        let signer = null;
        let userAddress = null;
        let currentTokenSelection = null; // 'from' or 'to'

        // Base network configuration
        const BASE_CHAIN_ID = '0x2105'; // 8453 in hex
        const BASE_RPC_URL = 'https://mainnet.base.org';

        // Curated Base network tokens - Most popular and verified tokens by trading volume
        const BASE_TOKENS = [
            {
                symbol: 'ETH',
                name: 'Ethereum',
                address: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
                decimals: 18,
                icon: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png',
                verified: true,
                popular: true
            },
            {
                symbol: 'USDC',
                name: 'USD Coin',
                address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
                decimals: 6,
                icon: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png',
                verified: true,
                popular: true
            },
            {
                symbol: 'WETH',
                name: 'Wrapped Ethereum',
                address: '0x4200000000000000000000000000000000000006',
                decimals: 18,
                icon: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png',
                verified: true,
                popular: true
            },
            {
                symbol: 'AERO',
                name: 'Aerodrome Finance',
                address: '0x940181a94a35a4569e4529a3cdfb74e38fd98631',
                decimals: 18,
                icon: 'https://assets.coingecko.com/coins/images/31745/small/token.png',
                verified: true,
                popular: true
            },
            {
                symbol: 'cbDOGE',
                name: 'Coinbase Wrapped DOGE',
                address: '0xcbD06E5A2B0C65597161de254AA074E489dEb510',
                decimals: 8,
                icon: 'https://assets.coingecko.com/coins/images/66268/standard/Coinbase_Wrapped_Doge_%28cbDOGE%29.png',
                verified: true,
                popular: true
            },
            {
                symbol: 'BRETT',
                name: 'Based Brett',
                address: '0x532f27101965dd16442e59d40670faf5ebb142e4',
                decimals: 18,
                icon: 'https://assets.coingecko.com/coins/images/35529/standard/1000050750.png',
                verified: true,
                popular: false
            },
            {
                symbol: 'DAI',
                name: 'Dai Stablecoin',
                address: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb',
                decimals: 18,
                icon: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png',
                verified: true,
                popular: false
            },
            {
                symbol: 'cbBTC',
                name: 'Coinbase Wrapped BTC',
                address: '0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf',
                decimals: 8,
                icon: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png',
                verified: true,
                popular: true
            },
            {
                symbol: 'USDbC',
                name: 'USD Base Coin',
                address: '0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA',
                decimals: 6,
                icon: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png',
                verified: true,
                popular: false
            }
        ];

        // Function to get token icon with fallback
        function getTokenIcon(address) {
            // Try multiple sources
            const token = BASE_TOKENS.find(t => t.address.toLowerCase() === address.toLowerCase());
            if (token?.icon) return token.icon;

            // Fallback to blockchain explorers or token lists
            // For Base chain tokens, we can use various sources
            return `https://raw.githubusercontent.com/base-org/brand-kit/main/logo/symbol/Base_Symbol_Blue.png`;
        }

        // Current token selection
        let fromToken = BASE_TOKENS[0]; // ETH
        let toToken = BASE_TOKENS[1]; // USDC

        // Connect wallet functionality
        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    showStatus('Please install MetaMask!', 'error');
                    return;
                }

                // Request account access
                await window.ethereum.request({ method: 'eth_requestAccounts' });

                // Switch to Base network
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: BASE_CHAIN_ID }],
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: BASE_CHAIN_ID,
                                chainName: 'Base',
                                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                rpcUrls: [BASE_RPC_URL],
                                blockExplorerUrls: ['https://basescan.org/']
                            }]
                        });
                    }
                }

                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();
                userAddress = await signer.getAddress();

                const walletButton = document.getElementById('connectWallet');
                walletButton.textContent = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                walletButton.classList.remove('not-connected');
                document.getElementById('swapButton').textContent = 'Enter Amount';
                document.getElementById('swapButton').disabled = false;

                await updateBalances();

                // Automatically scan wallet tokens in background
                setTimeout(() => {
                    detectWalletTokens();
                }, 500); // Small delay to let wallet fully initialize

                showStatus('Wallet connected successfully!', 'success');
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showStatus('Failed to connect wallet', 'error');
            }
        }

        // Storage for detected wallet tokens with caching
        let walletTokens = [];
        let walletTokensCache = new Map(); // Cache by wallet address
        let lastWalletScan = 0;
        const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

        // Update token balances and detect wallet tokens
        async function updateBalances() {
            if (!provider || !userAddress) return;

            try {
                // Update from token balance
                const fromBalance = await getTokenBalance(fromToken.address, userAddress);
                const fromBalanceElement = document.getElementById('fromBalance');
                fromBalanceElement.textContent = `Balance: ${fromBalance}`;

                // Store the raw balance for max functionality
                fromBalanceElement.dataset.rawBalance = fromBalance;

                // Update to token balance
                const toBalance = await getTokenBalance(toToken.address, userAddress);
                document.getElementById('toBalance').textContent = `Balance: ${toBalance}`;

                // Note: Wallet token detection now happens automatically on connect with smart caching
            } catch (error) {
                console.error('Error updating balances:', error);
            }
        }

        // Detect tokens in user's wallet automatically
        async function detectWalletTokens() {
            if (!provider || !userAddress) {
                console.log('⚠️ Wallet detection skipped - no provider or address');
                return;
            }

            // Check cache first
            const cacheKey = userAddress.toLowerCase();
            const now = Date.now();

            if (walletTokensCache.has(cacheKey) && (now - lastWalletScan) < CACHE_DURATION) {
                console.log('📦 Using cached wallet tokens');
                walletTokens = walletTokensCache.get(cacheKey);
                showStatus(`✨ Found ${walletTokens.length} cached tokens in your wallet!`, 'success');
                return;
            }

            try {
                console.log('🔍 Scanning wallet for tokens...', userAddress);
                // Show subtle scanning message only when actually scanning
                showStatus('🔍 Scanning for your tokens...', 'info');

                // Try Blockscout API V2 for Base network token balances
                const apiUrl = `https://base.blockscout.com/api/v2/addresses/${userAddress}/token-balances`;
                console.log('API URL:', apiUrl);

                const response = await fetch(apiUrl);
                const data = await response.json();
                console.log('Blockscout API response:', data);

                // Process Blockscout data if available
                if (data && Array.isArray(data) && data.length > 0) {
                    console.log(`Found ${data.length} token balances`);
                    console.log('Raw token data:', JSON.stringify(data, null, 2));
                    const detectedTokens = [];

                    // Process each token balance directly
                    for (const tokenData of data) {
                        console.log('Processing token data:', tokenData);

                        if (tokenData.token && tokenData.value) {
                            const token = tokenData.token;
                            const tokenAddress = token.address_hash; // Fixed: use address_hash from API
                            const tokenSymbol = token.symbol;
                            const tokenName = token.name || tokenSymbol;
                            const decimals = parseInt(token.decimals) || 18;
                            const rawBalance = tokenData.value;

                            console.log(`Token: ${tokenSymbol}, Address: ${tokenAddress}, Raw Balance: ${rawBalance}, Decimals: ${decimals}`);

                            // Check if we have an address and symbol (basic validation)
                            if (tokenAddress && tokenSymbol) {
                                try {
                                    // Format the balance properly using decimals (more precision for tiny amounts)
                                    const balanceInUnits = parseFloat(ethers.formatUnits(rawBalance, decimals));
                                    const formattedBalance = balanceInUnits < 1 ? balanceInUnits.toFixed(6) : balanceInUnits.toFixed(4);
                                    const balanceFloat = parseFloat(formattedBalance);

                                    console.log(`Formatted balance: ${formattedBalance}`);

                                    // Include tokens with any balance above dust level
                                    if (balanceFloat > 0.000001) { // Ultra-low threshold to catch tiny amounts like USDC
                                        // Check if token already exists in wallet list (but allow from other lists)
                                        const existsInWallet = walletTokens.find(t => t.address.toLowerCase() === tokenAddress.toLowerCase());

                                        if (!existsInWallet) {
                                            // DOUBLE-CHECK: Verify balance directly from blockchain (API can be stale)
                                            console.log(`🔍 Double-checking ${tokenSymbol} balance directly from blockchain...`);
                                            const realTimeBalance = await getTokenBalance(tokenAddress, userAddress);
                                            const realTimeFloat = parseFloat(realTimeBalance);

                                            console.log(`📊 ${tokenSymbol}: API balance = ${formattedBalance}, Real-time = ${realTimeBalance}`);

                                            // Only add if real-time balance confirms > 0
                                            if (realTimeFloat > 0.000001) {
                                                // Check if this token exists in BASE_TOKENS to get proper icon and verification
                                                const baseToken = BASE_TOKENS.find(t => t.address.toLowerCase() === tokenAddress.toLowerCase());
                                                const tokenIcon = baseToken?.icon || token.icon_url || await getTokenImage(tokenAddress, tokenSymbol);
                                                const isVerified = baseToken?.verified || false;

                                                const walletToken = {
                                                    symbol: tokenSymbol,
                                                    name: baseToken?.name || tokenName,
                                                    address: tokenAddress,
                                                    decimals: decimals,
                                                    icon: tokenIcon,
                                                    verified: isVerified, // Give same verification as base token
                                                    popular: false,
                                                    custom: false,
                                                    wallet: true, // Special flag for wallet-detected tokens
                                                    balance: realTimeBalance, // Use real-time balance, not API balance
                                                    truncatedAddress: truncateAddress(tokenAddress)
                                                };

                                                detectedTokens.push(walletToken);
                                                console.log(`✅ Added wallet token: ${tokenSymbol} (${realTimeBalance}) - confirmed by blockchain`);
                                            } else {
                                                console.log(`❌ Skipped ${tokenSymbol} - API shows ${formattedBalance} but blockchain shows ${realTimeBalance} (likely stale API data)`);
                                            }
                                        } else {
                                            console.log(`⏭️ Skipped ${tokenSymbol} - already in wallet list`);
                                        }
                                    } else {
                                        console.log(`⏭️ Skipped ${tokenSymbol} - balance too low (${formattedBalance}, avoiding dust/scam tokens)`);
                                    }
                                } catch (balanceError) {
                                    console.log(`Error formatting balance for ${tokenSymbol}:`, balanceError);
                                }
                            }
                        }
                    }

                    if (detectedTokens.length > 0) {
                        // Add to wallet tokens
                        walletTokens.push(...detectedTokens);

                        // Sort by balance (highest first)
                        walletTokens.sort((a, b) => parseFloat(b.balance) - parseFloat(a.balance));

                        // Cache the results
                        walletTokensCache.set(cacheKey, [...walletTokens]);
                        lastWalletScan = now;

                        console.log(`✨ Found ${detectedTokens.length} tokens in wallet:`, detectedTokens.map(t => `${t.symbol} (${t.balance})`));
                        showStatus(`✨ Found ${detectedTokens.length} tokens in your wallet!`, 'success');

                        // Update token list display if modal is open
                        if (document.getElementById('tokenModal').style.display === 'block') {
                            renderTokenList(document.getElementById('tokenSearch').value);
                        }
                    }
                }

                // Always check ETH and common tokens regardless of Blockscout results
                console.log('Checking ETH and common tokens...');
                const commonTokens = [
                    { address: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE', symbol: 'ETH', decimals: 18, name: 'Ethereum' }, // Native ETH
                    { address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', symbol: 'USDC', decimals: 6 },
                    { address: '0x4200000000000000000000000000000000000006', symbol: 'WETH', decimals: 18 },
                    { address: '0x940181a94A35A4569E4529A3CDfB74e38FD98631', symbol: 'AERO', decimals: 18 },
                    { address: '0x532f27101965dd16442E59d40670FaF5eBB142E4', symbol: 'BRETT', decimals: 18 },
                    { address: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb', symbol: 'DAI', decimals: 18 },
                    { address: '0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf', symbol: 'cbBTC', decimals: 8 },
                    { address: '0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA', symbol: 'USDbC', decimals: 6 },
                    { address: '0x4f9fd6be4a90f2620860d680c0d4d5fb53d1a825', symbol: 'AIXBT', decimals: 18, name: 'aixbt by Virtuals' } // AIXBT token
                ];

                const detectedTokens = [];
                for (const token of commonTokens) {
                    try {
                        const balance = await getTokenBalance(token.address, userAddress);
                        const balanceFloat = parseFloat(balance);
                        if (balanceFloat > 0.000001) { // Ultra-low threshold to catch tiny amounts like USDC
                            // Check if token already exists in wallet list (but allow from other lists)
                            const existsInWallet = walletTokens.find(t => t.address.toLowerCase() === token.address.toLowerCase());

                            if (!existsInWallet) {
                                // Check if this token exists in BASE_TOKENS to get proper icon and verification
                                const baseToken = BASE_TOKENS.find(t => t.address.toLowerCase() === token.address.toLowerCase());
                                const tokenIcon = baseToken?.icon || await getTokenImage(token.address, token.symbol);
                                const isVerified = baseToken?.verified || false;

                                detectedTokens.push({
                                    ...token,
                                    name: baseToken?.name || token.name || token.symbol,
                                    icon: tokenIcon,
                                    balance: balance,
                                    wallet: true,
                                    verified: isVerified, // Give same verification as base token
                                    popular: false,
                                    custom: false,
                                    truncatedAddress: truncateAddress(token.address)
                                });
                            }
                        }
                    } catch (err) {
                        console.log(`Failed to check ${token.symbol}:`, err);
                    }
                }

                if (detectedTokens.length > 0) {
                    walletTokens.push(...detectedTokens);
                    walletTokens.sort((a, b) => parseFloat(b.balance) - parseFloat(a.balance));

                    // Cache the fallback results too
                    walletTokensCache.set(cacheKey, [...walletTokens]);
                    lastWalletScan = now;

                    console.log(`✨ Found ${detectedTokens.length} tokens in wallet:`, detectedTokens.map(t => `${t.symbol} (${t.balance})`));
                    showStatus(`✨ Found ${detectedTokens.length} tokens in your wallet!`, 'success');
                    if (document.getElementById('tokenModal').style.display === 'block') {
                        renderTokenList(document.getElementById('tokenSearch').value);
                    }
                } else {
                    console.log('😕 No tokens with balance > 0 found');
                    // Cache empty result to avoid repeated scans
                    walletTokensCache.set(cacheKey, []);
                    lastWalletScan = now;
                }

            } catch (error) {
                console.error('Wallet token detection failed:', error);
                showStatus('Wallet scan failed - will continue without auto-detection', 'error');
            }
        }

        // Get token balance
        async function getTokenBalance(tokenAddress, userAddress) {
            if (tokenAddress === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE') {
                // ETH balance
                const balance = await provider.getBalance(userAddress);
                return parseFloat(ethers.formatEther(balance)).toFixed(4);
            } else {
                // ERC20 token balance
                const contract = new ethers.Contract(tokenAddress, [
                    'function balanceOf(address) view returns (uint256)',
                    'function decimals() view returns (uint8)'
                ], provider);

                const balance = await contract.balanceOf(userAddress);
                const decimals = await contract.decimals();
                return parseFloat(ethers.formatUnits(balance, decimals)).toFixed(4);
            }
        }

        // MAX BALANCE CLICK FUNCTIONALITY
        function handleMaxBalanceClick() {
            const fromBalanceElement = document.getElementById('fromBalance');
            const rawBalance = fromBalanceElement.dataset.rawBalance;

            if (!rawBalance || parseFloat(rawBalance) === 0) {
                showStatus('No balance available to use', 'error');
                return;
            }

            // Set the max balance in the input
            const fromAmountInput = document.getElementById('fromAmount');
            fromAmountInput.value = rawBalance;

            // Trigger the input event to get a new quote
            fromAmountInput.dispatchEvent(new Event('input'));

            // Visual feedback

            // Quick visual feedback on the balance element
            fromBalanceElement.style.transform = 'scale(1.1)';
            fromBalanceElement.style.color = '#FE745B';
            setTimeout(() => {
                fromBalanceElement.style.transform = 'scale(1)';
                fromBalanceElement.style.color = '';
            }, 200);
        }

        // Token selection modal
        // Global search state
        let customTokens = [];
        let searchTimeout = null;

        function renderTokenList(searchQuery = '') {
            const tokenList = document.getElementById('tokenList');
            tokenList.innerHTML = '';

            // Filter tokens based on search query (include wallet tokens)
            const filteredTokens = [...BASE_TOKENS, ...customTokens, ...walletTokens].filter(token => {
                if (!searchQuery) return true;
                const query = searchQuery.toLowerCase();
                return (
                    token.symbol.toLowerCase().includes(query) ||
                    token.name.toLowerCase().includes(query) ||
                    token.address.toLowerCase().includes(query)
                );
            });

            // Separate tokens into categories
            const walletTokensFiltered = filteredTokens.filter(token => token.wallet);

            // Get wallet token addresses to avoid duplicates in popular section
            const walletAddresses = walletTokensFiltered.map(t => t.address.toLowerCase());

            const popularTokensFiltered = filteredTokens.filter(token =>
                !token.wallet &&
                token.popular &&
                !walletAddresses.includes(token.address.toLowerCase()) // Avoid duplicates
            );
            const otherTokensFiltered = filteredTokens.filter(token =>
                !token.wallet &&
                !token.popular &&
                !walletAddresses.includes(token.address.toLowerCase()) // Avoid duplicates
            );

            // Sort each category
            walletTokensFiltered.sort((a, b) => parseFloat(b.balance || '0') - parseFloat(a.balance || '0'));
            popularTokensFiltered.sort((a, b) => a.symbol.localeCompare(b.symbol));
            otherTokensFiltered.sort((a, b) => a.symbol.localeCompare(b.symbol));

            // Render sections
            let hasRenderedContent = false;

            // Wallet tokens section
            if (walletTokensFiltered.length > 0) {
                const walletSection = document.createElement('div');
                walletSection.style.cssText = 'display: flex; justify-content: space-between; align-items: center; color: rgba(254, 116, 91, 0.8); font-size: 12px; font-weight: 600; padding: 8px 12px 4px; margin-top: 4px; text-transform: uppercase; letter-spacing: 0.5px;';
                walletSection.innerHTML = `
                    <span>🪙 In My Wallet (${walletTokensFiltered.length})</span>
                    <button onclick="refreshWalletTokens()" style="
                        background: rgba(255,255,255,0.1);
                        border: none;
                        color: rgba(255,255,255,0.7);
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-size: 10px;
                        cursor: pointer;
                        transition: all 0.2s;
                    " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                        🔄 Refresh
                    </button>
                `;
                tokenList.appendChild(walletSection);

                walletTokensFiltered.forEach(token => {
                    tokenList.appendChild(createTokenItem(token));
                });
                hasRenderedContent = true;
            }

            // Popular tokens section
            if (popularTokensFiltered.length > 0) {
                if (hasRenderedContent) {
                    const divider = document.createElement('div');
                    divider.style.cssText = 'height: 1px; background: rgba(255,255,255,0.1); margin: 8px 12px;';
                    tokenList.appendChild(divider);
                }

                const popularSection = document.createElement('div');
                popularSection.style.cssText = 'color: rgba(255, 255, 255, 0.6); font-size: 12px; font-weight: 600; padding: 8px 12px 4px; text-transform: uppercase; letter-spacing: 0.5px;';
                popularSection.textContent = '⭐ Popular Tokens';
                tokenList.appendChild(popularSection);

                popularTokensFiltered.forEach(token => {
                    tokenList.appendChild(createTokenItem(token));
                });
                hasRenderedContent = true;
            }

            // Other tokens section
            if (otherTokensFiltered.length > 0) {
                if (hasRenderedContent) {
                    const divider = document.createElement('div');
                    divider.style.cssText = 'height: 1px; background: rgba(255,255,255,0.1); margin: 8px 12px;';
                    tokenList.appendChild(divider);
                }

                const otherSection = document.createElement('div');
                otherSection.style.cssText = 'color: rgba(255, 255, 255, 0.6); font-size: 12px; font-weight: 600; padding: 8px 12px 4px; text-transform: uppercase; letter-spacing: 0.5px;';
                otherSection.textContent = '🔗 Other Tokens';
                tokenList.appendChild(otherSection);

                otherTokensFiltered.forEach(token => {
                    tokenList.appendChild(createTokenItem(token));
                });
                hasRenderedContent = true;
            }

            // Show "No results" if no tokens found
            if (!hasRenderedContent) {
                tokenList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">No tokens found</div>';
                return;
            }
        }

        // Helper function to create token item element
        function createTokenItem(token) {
            const tokenItem = document.createElement('div');
            tokenItem.className = 'token-item';
            const verifiedBadge = token.verified ? '<span style="color: #4CAF50; margin-left: 4px;">✓</span>' : '';

            // Enhanced display for custom tokens
            let nameDisplay = token.name;
            let additionalInfo = '';

            // Show balance for wallet tokens
            if (token.wallet && token.balance) {
                additionalInfo = `
                    <div style="color: rgba(255, 255, 255, 0.6); font-size: 11px; margin-top: 2px; font-weight: 500;">
                        ${token.balance}
                    </div>
                `;
            } else if (token.custom) {
                // Only show truncated address for custom tokens
                additionalInfo = `
                    <div style="color: rgba(255,255,255,0.5); font-size: 10px; margin-top: 2px;">
                        ${token.truncatedAddress || truncateAddress(token.address)}
                    </div>
                `;
            }

            // Handle loading state for icons
            let iconHtml;
            if (token.icon === 'loading') {
                iconHtml = `
                    <div style="
                        width: 32px;
                        height: 32px;
                        border-radius: 50%;
                        background: linear-gradient(45deg, #667eea, #764ba2);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        animation: spin 1s linear infinite;
                    ">
                        <div style="
                            width: 12px;
                            height: 12px;
                            border: 2px solid white;
                            border-top: 2px solid transparent;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                        "></div>
                    </div>
                `;
            } else {
                iconHtml = `<img class="token-item-icon" src="${token.icon}" alt="${token.symbol}" style="width: 32px; height: 32px; border-radius: 50%;">`;
            }

            tokenItem.innerHTML = `
                ${iconHtml}
                <div class="token-item-info">
                    <div class="token-item-symbol">${token.symbol}${verifiedBadge}</div>
                    <div class="token-item-name">${nameDisplay}</div>
                    ${additionalInfo}
                </div>
            `;
            tokenItem.onclick = () => selectToken(token);
            return tokenItem;
        }

        function openTokenModal(type) {
            currentTokenSelection = type;
            const modal = document.getElementById('tokenModal');
            const tokenSearch = document.getElementById('tokenSearch');

            // Clear search and render all tokens
            tokenSearch.value = '';
            renderTokenList();

            // Focus search input
            modal.style.display = 'block';
            setTimeout(() => tokenSearch.focus(), 100);
        }

        function closeTokenModal() {
            document.getElementById('tokenModal').style.display = 'none';
        }

        // Helper functions for Phase 2
        function isValidAddress(address) {
            return /^0x[a-fA-F0-9]{40}$/.test(address);
        }

        function findTokenByAddress(address) {
            return [...BASE_TOKENS, ...customTokens].find(token =>
                token.address.toLowerCase() === address.toLowerCase()
            );
        }

        // Token image providers with fallback chain
        async function getTokenImage(address, symbol) {
            const checksumAddress = toChecksumAddress(address);

            // Provider chain: MetaMask → Trust Wallet → 1inch → CoinGecko → Fallback
            const providers = [
                // MetaMask API (Best for newer Base tokens)
                `https://static.cx.metamask.io/api/v1/tokenIcons/8453/${checksumAddress}.png`,
                // Trust Wallet (Base network)
                `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/base/assets/${checksumAddress}/logo.png`,
                // Trust Wallet (Ethereum network as fallback)
                `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${checksumAddress}/logo.png`,
                // 1inch token list
                `https://tokens.1inch.io/${checksumAddress}.png`,
                // CoinGecko fallback (we'll implement API call)
                'coingecko-api'
            ];

            for (const provider of providers) {
                try {
                    if (provider === 'coingecko-api') {
                        // Try CoinGecko API (free tier)
                        const imageUrl = await getCoinGeckoImage(address);
                        if (imageUrl && await validateImage(imageUrl)) {
                            return imageUrl;
                        }
                    } else {
                        // Test static URL
                        if (await validateImage(provider)) {
                            return provider;
                        }
                    }
                } catch (error) {
                    console.log(`Provider failed: ${provider}`, error);
                    continue;
                }
            }

            // Final fallback: generate a professional-looking placeholder
            return generateTokenPlaceholder(symbol);
        }

        // EIP-55 checksum address converter (using ethers v6 compatible method)
        function toChecksumAddress(address) {
            if (!address) return address;

            try {
                // Try ethers v6 method first
                if (ethers.getAddress) {
                    return ethers.getAddress(address);
                }

                // Fallback to manual implementation
                address = address.toLowerCase().replace('0x', '');
                const hash = ethers.utils.keccak256('0x' + address).replace('0x', '');
                let checksum = '0x';

                for (let i = 0; i < 40; i++) {
                    if (parseInt(hash[i], 16) >= 8) {
                        checksum += address[i].toUpperCase();
                    } else {
                        checksum += address[i];
                    }
                }
                return checksum;
            } catch (error) {
                console.log('Checksum conversion failed, using original address:', error);
                return address;
            }
        }

        // Validate if image URL loads successfully
        function validateImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = url;
                // Timeout after 3 seconds
                setTimeout(() => resolve(false), 3000);
            });
        }

        // CoinGecko API fallback (free tier)
        async function getCoinGeckoImage(address) {
            try {
                // Use free CoinGecko search API
                const response = await fetch(`https://api.coingecko.com/api/v3/search?query=${address}`);
                const data = await response.json();

                if (data.coins && data.coins.length > 0) {
                    const coin = data.coins.find(c =>
                        c.platforms && Object.values(c.platforms).some(addr =>
                            addr && addr.toLowerCase() === address.toLowerCase()
                        )
                    );
                    return coin?.large || coin?.small || coin?.thumb;
                }
            } catch (error) {
                console.log('CoinGecko API failed:', error);
            }
            return null;
        }

        // Generate professional placeholder with token symbol
        function generateTokenPlaceholder(symbol) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;

            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, 64, 64);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            // Add symbol text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(symbol.slice(0, 4), 32, 32);

            return canvas.toDataURL();
        }

        // Truncate address for display (like Uniswap)
        function truncateAddress(address) {
            if (!address) return '';
            return `${address.slice(0, 6)}...${address.slice(-4)}`;
        }

        async function fetchCustomToken(address) {
            try {
                if (!provider) {
                    // Show message in token modal instead of blurred background
                    const tokenList = document.getElementById('tokenList');
                    tokenList.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #FF6B6B;">
                            <div style="font-size: 48px; margin-bottom: 16px;">🔗</div>
                            <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">Connect Wallet Required</div>
                            <div style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 20px;">Please connect your wallet to search for tokens</div>
                            <button onclick="connectWallet()" style="
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                border: none;
                                padding: 12px 24px;
                                border-radius: 12px;
                                cursor: pointer;
                                font-weight: 600;
                                transition: transform 0.2s;
                            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                Connect Wallet
                            </button>
                        </div>
                    `;
                    return;
                }

                const tokenList = document.getElementById('tokenList');
                tokenList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 20px;">🔍 Fetching token info...</div>';

                // Create contract instances to fetch metadata
                const tokenContract = new ethers.Contract(address, [
                    'function symbol() view returns (string)',
                    'function name() view returns (string)',
                    'function decimals() view returns (uint8)',
                    'function totalSupply() view returns (uint256)'
                ], provider);

                // Fetch token metadata
                const [symbol, name, decimals] = await Promise.all([
                    tokenContract.symbol(),
                    tokenContract.name(),
                    tokenContract.decimals()
                ]);

                // Create token object with loading spinner for image (INSTANT DISPLAY)
                const customToken = {
                    symbol,
                    name,
                    address,
                    decimals,
                    icon: 'loading', // Special loading state
                    verified: false,
                    popular: false,
                    custom: true,
                    truncatedAddress: truncateAddress(address)
                };

                // Add to custom tokens if not already present
                if (!customTokens.find(t => t.address.toLowerCase() === address.toLowerCase())) {
                    customTokens.unshift(customToken);
                }

                // Show token IMMEDIATELY (don't wait for image)
                renderTokenList(document.getElementById('tokenSearch').value);
                showStatus(`✅ Found ${symbol} token`, 'success');

                // Load image asynchronously in background
                getTokenImage(address, symbol).then(tokenIcon => {
                    // Update the token with the real image
                    const tokenIndex = customTokens.findIndex(t => t.address.toLowerCase() === address.toLowerCase());
                    if (tokenIndex !== -1) {
                        customTokens[tokenIndex].icon = tokenIcon;
                        // Re-render to show the loaded image
                        renderTokenList(document.getElementById('tokenSearch').value);
                    }
                }).catch(error => {
                    console.log('Image loading failed, using fallback:', error);
                    // Update with fallback image
                    const tokenIndex = customTokens.findIndex(t => t.address.toLowerCase() === address.toLowerCase());
                    if (tokenIndex !== -1) {
                        customTokens[tokenIndex].icon = generateTokenPlaceholder(symbol);
                        renderTokenList(document.getElementById('tokenSearch').value);
                    }
                });

            } catch (error) {
                console.error('Error fetching token:', error);
                const tokenList = document.getElementById('tokenList');
                tokenList.innerHTML = '<div style="text-align: center; color: #FF5555; padding: 20px;">❌ Invalid token address or contract not found</div>';
                showStatus('❌ Invalid token address', 'error');
            }
        }

        function selectToken(token) {
            if (currentTokenSelection === 'from') {
                fromToken = token;
                document.getElementById('fromTokenSymbol').textContent = token.symbol;
                document.getElementById('fromTokenIcon').src = token.icon;
                document.getElementById('fromTokenIcon').alt = token.symbol;
            } else {
                toToken = token;
                document.getElementById('toTokenSymbol').textContent = token.symbol;
                document.getElementById('toTokenIcon').src = token.icon;
                document.getElementById('toTokenIcon').alt = token.symbol;
            }

            closeTokenModal();
            updateBalances();

            // Get new quote if there's an amount
            const fromAmount = document.getElementById('fromAmount').value;
            if (fromAmount && parseFloat(fromAmount) > 0) {
                getQuote();
            }
        }

        // Switch tokens
        function switchTokens() {
            const tempToken = fromToken;
            fromToken = toToken;
            toToken = tempToken;

            document.getElementById('fromTokenSymbol').textContent = fromToken.symbol;
            document.getElementById('toTokenSymbol').textContent = toToken.symbol;
            document.getElementById('fromTokenIcon').src = fromToken.icon;
            document.getElementById('toTokenIcon').src = toToken.icon;
            document.getElementById('fromTokenIcon').alt = fromToken.symbol;
            document.getElementById('toTokenIcon').alt = toToken.symbol;

            // Swap the amounts too
            const fromAmount = document.getElementById('fromAmount').value;
            const toAmount = document.getElementById('toAmount').value;
            document.getElementById('fromAmount').value = toAmount;
            document.getElementById('toAmount').value = fromAmount;

            updateBalances();

            // Get new quote if there's an amount
            if (document.getElementById('fromAmount').value) {
                getQuote();
            }
        }

        // Show status message with optional close button
        function showStatus(message, type, persistent = false) {
            const statusElement = document.getElementById('statusMessage');

            // Add close button for success messages
            if (type === 'success' && persistent) {
                statusElement.innerHTML = `
                    ${message}
                    <button class="close-status" onclick="closeStatus()">×</button>
                `;
            } else {
                statusElement.innerHTML = message;
            }

            statusElement.className = `status-message ${type}`;
            statusElement.style.display = 'block';

            // Auto-hide non-persistent messages
            if (!persistent) {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 5000);
            }
        }

        // Close status message
        function closeStatus() {
            document.getElementById('statusMessage').style.display = 'none';
        }

        // Refresh wallet tokens manually (clears cache and re-scans)
        function refreshWalletTokens() {
            console.log('🔄 Manual wallet refresh triggered');
            walletTokens = [];
            walletTokensCache.clear();
            lastWalletScan = 0;
            detectWalletTokens().then(() => {
                // Update token list if modal is open
                if (document.getElementById('tokenModal').style.display === 'block') {
                    renderTokenList(document.getElementById('tokenSearch').value);
                }
            });
        }

        // Get quote for swap with TTL guard
        let quoteTimeout = null;
        let lastQuote = null;
        let lastQuoteTime = 0;

        async function getQuote() {
            const fromAmount = document.getElementById('fromAmount').value;

            if (!fromAmount || parseFloat(fromAmount) <= 0) {
                document.getElementById('toAmount').value = '';
                lastQuote = null;
                lastQuoteTime = 0;
                return;
            }

            try {
                // Convert amount to smallest unit
                const sellAmount = ethers.parseUnits(fromAmount, fromToken.decimals).toString();

                // Use V3 quote endpoint
                const response = await fetch('/api/v3-quote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sellToken: fromToken.address,
                        buyToken: toToken.address,
                        sellAmount: sellAmount,
                        taker: userAddress || '0x0000000000000000000000000000000000000000'
                    })
                });

                const quote = await response.json();

                if (quote.buyAmount) {
                    const buyAmount = ethers.formatUnits(quote.buyAmount, toToken.decimals);
                    document.getElementById('toAmount').value = parseFloat(buyAmount).toFixed(6);

                    // Store quote with timestamp for TTL guard
                    lastQuote = quote;
                    lastQuoteTime = Date.now();
                }
            } catch (error) {
                console.error('Error getting quote:', error);
            }
        }

        // TTL guard function - check if quote is too old (>10s)
        function isQuoteFresh() {
            if (!lastQuote || !lastQuoteTime) return false;
            return (Date.now() - lastQuoteTime) < 10000; // 10 seconds
        }

        // Execute real swap using V3 API
        async function executeSwap() {
            if (!signer || !userAddress) {
                showStatus('Please connect wallet first', 'error');
                await connectWallet();
                return;
            }

            const fromAmount = document.getElementById('fromAmount').value;
            if (!fromAmount || parseFloat(fromAmount) <= 0) {
                showStatus('Please enter a valid amount', 'error');
                return;
            }

            const btn = document.getElementById('swapButton');

            try {
                // Step 0: Ensure wallet is fully ready
                btn.textContent = 'Checking wallet...';
                btn.disabled = true;
                showStatus('🔗 Ensuring wallet connectivity...', 'info');

                // Wait for wallet to be fully initialized
                if (!provider || !signer || !userAddress) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (!provider || !signer || !userAddress) {
                        throw new Error('Wallet not properly connected. Please reconnect.');
                    }
                }

                // Verify network is correct
                const network = await provider.getNetwork();
                if (network.chainId !== 8453n) {
                    throw new Error('Please switch to Base network');
                }

                // Step 1: Check if we need a fresh quote (TTL guard)
                if (!isQuoteFresh()) {
                    btn.textContent = 'Getting Fresh Quote...';
                    showStatus('🔄 Getting fresh quote (previous quote expired)...', 'info');
                    await getQuote(); // Get fresh quote
                }

                if (!lastQuote) {
                    btn.textContent = 'Getting Quote...';
                    showStatus('🔄 Getting quote...', 'info');
                    await getQuote();
                }

                if (!lastQuote) {
                    throw new Error('Failed to get quote');
                }

                const sellAmount = ethers.parseUnits(fromAmount, fromToken.decimals).toString();

                const response = await fetch('/api/v3-quote', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sellToken: fromToken.address,
                        buyToken: toToken.address,
                        sellAmount: sellAmount,
                        taker: userAddress
                    })
                });

                if (!response.ok) throw new Error('Failed to get quote');
                const swapData = await response.json();

                const buyAmount = ethers.formatUnits(swapData.buyAmount, toToken.decimals);
                console.log(`✅ Quote: ${fromAmount} ${fromToken.symbol} → ${buyAmount} ${toToken.symbol}`);

                // Step 2: Check if we need token approval for ERC-20 tokens
                if (fromToken.address !== '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE') {
                    // Get the spender address (0x Exchange Proxy for Base)
                    const spender = swapData.to; // The contract we're sending the transaction to

                    // Check current allowance
                    const tokenContract = new ethers.Contract(
                        fromToken.address,
                        [
                            'function allowance(address owner, address spender) view returns (uint256)',
                            'function approve(address spender, uint256 amount) returns (bool)'
                        ],
                        provider
                    );

                    const currentAllowance = await tokenContract.allowance(userAddress, spender);
                    const requiredAmount = BigInt(sellAmount);

                    // If allowance is insufficient, approve
                    if (currentAllowance < requiredAmount) {
                        btn.textContent = 'Approve token...';
                        showStatus('📱 Please approve token spending in MetaMask', 'info');

                        // Create approval transaction with signer
                        const tokenContractWithSigner = tokenContract.connect(signer);
                        const approveTx = await tokenContractWithSigner.approve(
                            spender,
                            ethers.MaxUint256 // Approve max amount to avoid future approvals
                        );

                        btn.textContent = 'Approving...';
                        showStatus('⏳ Approving token...', 'info');
                        await approveTx.wait();

                        // Get fresh quote after approval
                        btn.textContent = 'Getting new quote...';
                        const retryResponse = await fetch('/api/v3-quote', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                sellToken: fromToken.address,
                                buyToken: toToken.address,
                                sellAmount: sellAmount,
                                taker: userAddress
                            })
                        });

                        if (!retryResponse.ok) throw new Error('Failed to get quote after approval');
                        swapData = await retryResponse.json();
                        showStatus('✅ Token approved successfully', 'success');
                    }
                }

                // Step 3: Get fresh quote just before execution to avoid stale data
                btn.textContent = 'Getting final quote...';
                const finalQuoteResponse = await fetch('/api/v3-quote', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sellToken: fromToken.address,
                        buyToken: toToken.address,
                        sellAmount: sellAmount,
                        taker: userAddress
                    })
                });

                if (!finalQuoteResponse.ok) throw new Error('Failed to get final quote');
                const finalSwapData = await finalQuoteResponse.json();

                // Step 4: Execute transaction with fresh data
                btn.textContent = 'Confirming swap...';
                showStatus('📱 Please confirm the swap in MetaMask', 'info');

                const txParams = {
                    to: finalSwapData.to,
                    data: finalSwapData.data,
                    value: BigInt(finalSwapData.value || '0')
                };

                // Simulate transaction first to catch reverts early
                try {
                    await provider.call({
                        ...txParams,
                        from: userAddress
                    });
                } catch (simulationError) {
                    console.error('Transaction simulation failed:', simulationError);
                    throw new Error(`Transaction would fail: ${simulationError.message}`);
                }

                // Estimate gas with buffer
                const gasEstimate = await provider.estimateGas({
                    ...txParams,
                    from: userAddress
                });
                const gasLimit = gasEstimate + (gasEstimate / 5n); // Add 20% buffer

                // Send transaction
                btn.textContent = 'Processing...';
                const tx = await signer.sendTransaction({
                    ...txParams,
                    gasLimit: gasLimit
                });

                showStatus('⏳ Swap processing...', 'info');

                // Wait for confirmation
                btn.textContent = 'Finalizing...';
                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    showStatus(
                        `✅ Swap successful! <a href="https://basescan.org/tx/${tx.hash}" target="_blank">View transaction</a>`,
                        'success',
                        true // Make it persistent with close button
                    );

                    // Clear wallet token cache since wallet state changed
                    console.log('🗑️ Clearing wallet cache after successful swap');
                    walletTokens = [];
                    walletTokensCache.clear();
                    lastWalletScan = 0;

                    // Clear inputs and update balances
                    document.getElementById('fromAmount').value = '';
                    document.getElementById('toAmount').value = '';
                    await updateBalances();

                    // Re-scan wallet tokens after a short delay to pick up new tokens
                    setTimeout(() => {
                        detectWalletTokens();
                    }, 2000); // 2 second delay to let blockchain settle
                } else {
                    throw new Error('Transaction failed');
                }

                btn.textContent = 'Swap';
                btn.disabled = false;

            } catch (error) {
                console.error('Swap error:', error);
                let errorMsg = 'Swap failed. ';

                // Enhanced error handling with more specific messages
                if (error.message?.includes('insufficient funds')) {
                    errorMsg = 'Insufficient balance for this swap';
                } else if (error.message?.includes('user rejected') || error.message?.includes('User denied')) {
                    errorMsg = 'Transaction cancelled';
                } else if (error.message?.includes('allowance')) {
                    errorMsg = 'Token approval needed - please try again';
                } else if (error.message?.includes('Transaction would fail')) {
                    errorMsg = 'Swap conditions changed - please try again';
                } else if (error.message?.includes('execution reverted')) {
                    // Try to extract revert reason
                    if (error.receipt && error.receipt.status === 0) {
                        errorMsg = 'Transaction reverted - likely due to price impact or slippage';
                    } else {
                        errorMsg = 'Transaction failed - please try again';
                    }
                } else if (error.message?.includes('network')) {
                    errorMsg = 'Network error - please check connection';
                } else {
                    errorMsg += error.message?.substring(0, 100) || 'Please try again';
                }

                showStatus(errorMsg, 'error');
                btn.textContent = 'Swap';
                btn.disabled = false;
            }
        }

        // Event listeners
        document.getElementById('connectWallet').addEventListener('click', connectWallet);
        document.getElementById('fromTokenSelector').addEventListener('click', () => openTokenModal('from'));
        document.getElementById('toTokenSelector').addEventListener('click', () => openTokenModal('to'));
        document.getElementById('switchTokens').addEventListener('click', switchTokens);
        document.getElementById('swapButton').addEventListener('click', executeSwap);
        document.getElementById('closeModal').addEventListener('click', closeTokenModal);

        // SEARCH FUNCTIONALITY
        document.getElementById('tokenSearch').addEventListener('input', (e) => {
            const query = e.target.value;
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (isValidAddress(query) && !findTokenByAddress(query)) {
                    fetchCustomToken(query);
                } else {
                    renderTokenList(query);
                }
            }, 300);
        });

        // KEYBOARD SHORTCUTS
        document.getElementById('tokenSearch').addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeTokenModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('tokenModal').style.display === 'block') {
                closeTokenModal();
            }
        });

        // MAX BALANCE CLICK EVENT LISTENER
        document.getElementById('fromBalance').addEventListener('click', handleMaxBalanceClick);

        // Close modal when clicking outside
        document.getElementById('tokenModal').addEventListener('click', (e) => {
            if (e.target.id === 'tokenModal') {
                closeTokenModal();
            }
        });

        // Amount input handler with debounced quote
        document.getElementById('fromAmount').addEventListener('input', (e) => {
            const amount = e.target.value;

            // Update button state
            if (amount && parseFloat(amount) > 0) {
                document.getElementById('swapButton').textContent = 'Swap';
                document.getElementById('swapButton').disabled = false;

                // Debounce quote fetching to avoid too many API calls
                clearTimeout(quoteTimeout);
                quoteTimeout = setTimeout(() => {
                    getQuote();
                }, 500);
            } else {
                document.getElementById('swapButton').textContent = userAddress ? 'Enter Amount' : 'Connect Wallet';
                document.getElementById('swapButton').disabled = !userAddress;
                document.getElementById('toAmount').value = '';
            }
        });
        // Function to show "Coming Soon" modal for footer links
        function showComingSoon() {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(5px);
            `;

            // Create modal content
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
                padding: 40px;
                border-radius: 20px;
                text-align: center;
                border: 1px solid #333;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                margin: 20px;
            `;

            modal.innerHTML = `
                <h2 style="color: #ff6b35; margin-bottom: 20px; font-size: 24px;">Coming Soon!</h2>
                <p style="color: #ccc; margin-bottom: 30px; line-height: 1.6;">
                    This feature is currently under development. Stay tuned for updates!
                </p>
                <button onclick="this.closest('[style*=\"position: fixed\"]').remove()"
                        style="background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
                               color: white;
                               border: none;
                               padding: 12px 30px;
                               border-radius: 25px;
                               cursor: pointer;
                               font-weight: 600;
                               transition: transform 0.2s;
                               font-size: 16px;"
                        onmouseover="this.style.transform='scale(1.05)'"
                        onmouseout="this.style.transform='scale(1)'">
                    Got it!
                </button>
            `;

            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            // Close modal when clicking overlay
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
        }
    </script>

    <!-- Footer -->
    <div class="footer">
        <div class="footer-content">
            <div class="footer-socials">
                <h3>Connect</h3>
                <div class="social-icons">
                    <a href="https://twitter.com/pearswap" target="_blank" class="social-icon">𝕏</a>
                    <a href="https://discord.gg/pearswap" target="_blank" class="social-icon">Discord</a>
                    <a href="https://t.me/pearswap" target="_blank" class="social-icon">Telegram</a>
                    <a href="https://github.com/pearswap" target="_blank" class="social-icon">GitHub</a>
                </div>
            </div>
            <div class="footer-links">
                <h3>Learn</h3>
                <div class="footer-links-list">
                    <a href="/technology" class="footer-link">Technology</a>
                    <a href="/roadmap" class="footer-link">Roadmap</a>
                    <a href="/terms" class="footer-link">Terms of Service</a>
                    <span class="footer-link" onclick="showComingSoon()">Documentation</span>
                </div>
            </div>
        </div>
    </div>
</body>
</html>